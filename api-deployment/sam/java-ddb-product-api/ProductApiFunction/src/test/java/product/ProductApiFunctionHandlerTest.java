package product;

import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import product.exception.ProductNotFoundException;
import product.model.Product;
import product.persist.MockProductDatastore;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;


public class ProductApiFunctionHandlerTest {
  private MockProductDatastore mockDatastore; // To allow re-initialization or clearing
  private ProductApiFunctionHandler classUnderTest;
  private final ObjectMapper mapper = new ObjectMapper();

  @BeforeEach
  void setUp() {
    mockDatastore = new MockProductDatastore(); // Fresh mock for each test
    classUnderTest = new ProductApiFunctionHandler(mockDatastore);
  }

  @Test
  void shouldGetAllProducts() throws JsonProcessingException {
    // Mock datastore is pre-populated with one product by its constructor
    APIGatewayProxyRequestEvent event = new APIGatewayProxyRequestEvent();
    event.setHttpMethod("GET");
    event.setPath("/api/v1/products"); // Set path for clarity

    APIGatewayProxyResponseEvent result = classUnderTest.handleRequest(event, null);
    String content = result.getBody();
    List<Product> products = mapper.readValue(content, new TypeReference<List<Product>>() {});

    assertAll(
            () -> assertEquals(200, result.getStatusCode().intValue()),
            () -> assertEquals("application/json", result.getHeaders().get("Content-Type")),
            () -> assertNotNull(products),
            () -> assertFalse(products.isEmpty(), "Should return at least one product from mock"),
            () -> assertEquals(mockDatastore.listProducts().getFirst().getName(), products.getFirst().getName()) // Compare with what mock provides
    );
  }

  @Test
  void shouldAddNewProduct() throws JsonProcessingException {
    APIGatewayProxyRequestEvent event = new APIGatewayProxyRequestEvent();
    event.setHttpMethod("POST"); // As per template.yaml
    event.setPath("/api/v1/products");

    Product productToCreate = new Product();
    // Don't set ID, expect server to generate it for POST
    productToCreate.setName("New POSTed Product");
    productToCreate.setDescription("Description for POSTed product");
    productToCreate.setPrice(25.99);
    event.setBody(mapper.writeValueAsString(productToCreate));

    APIGatewayProxyResponseEvent result = classUnderTest.handleRequest(event, null);
    String content = result.getBody();
    Product createdProduct = mapper.readValue(content, Product.class);

    assertAll(
            () -> assertEquals(201, result.getStatusCode().intValue(), "Expected 201 Created for POST"),
            () -> assertEquals("application/json", result.getHeaders().get("Content-Type")),
            () -> assertNotNull(createdProduct.getId(), "ID should be generated by server"),
            () -> assertFalse(createdProduct.getId().isEmpty()),
            () -> assertEquals(productToCreate.getName(), createdProduct.getName()),
            () -> assertEquals(productToCreate.getDescription(), createdProduct.getDescription()),
            () -> assertEquals(productToCreate.getPrice(), createdProduct.getPrice())
    );
  }

  @Test
  void shouldGetASpecificProduct() throws JsonProcessingException {
    Product existingProduct = mockDatastore.listProducts().getFirst(); // Get the pre-populated product
    String existingProductId = existingProduct.getId();

    APIGatewayProxyRequestEvent event = new APIGatewayProxyRequestEvent();
    event.setHttpMethod("GET");
    event.setPath("/api/v1/products/" + existingProductId);
    event.setPathParameters(Map.of("id", existingProductId));

    APIGatewayProxyResponseEvent result = classUnderTest.handleRequest(event, null);
    String content = result.getBody();
    Product fetchedProduct = mapper.readValue(content, Product.class);

    assertAll(
            () -> assertEquals(200, result.getStatusCode().intValue()),
            () -> assertEquals(existingProductId, fetchedProduct.getId()),
            () -> assertEquals(existingProduct.getName(), fetchedProduct.getName())
    );
  }

  @Test
  void shouldNotGetNonExistentProduct() {
    String nonExistentId = UUID.randomUUID().toString();
    APIGatewayProxyRequestEvent event = new APIGatewayProxyRequestEvent();
    event.setHttpMethod("GET");
    event.setPath("/api/v1/products/" + nonExistentId);
    event.setPathParameters(Map.of("id", nonExistentId));

    APIGatewayProxyResponseEvent result = classUnderTest.handleRequest(event, null);

    assertEquals(404, result.getStatusCode().intValue(), "Expected 404 Not Found");
  }

  @Test
  void shouldUpdateProduct() throws JsonProcessingException {
    Product productToUpdate = mockDatastore.listProducts().get(0); // Get the pre-populated one
    String productId = productToUpdate.getId();

    APIGatewayProxyRequestEvent event = new APIGatewayProxyRequestEvent();
    event.setHttpMethod("PUT");
    event.setPath("/api/v1/products/" + productId);
    event.setPathParameters(Map.of("id", productId));

    Product updatedDetails = new Product();
    updatedDetails.setId(productId); // ID must match for an update
    updatedDetails.setName("Updated Product Name");
    updatedDetails.setDescription("Updated Description");
    updatedDetails.setPrice(99.99);
    event.setBody(mapper.writeValueAsString(updatedDetails));

    APIGatewayProxyResponseEvent result = classUnderTest.handleRequest(event, null);
    String content = result.getBody();
    Product updatedProduct = mapper.readValue(content, Product.class);

    assertAll(
            () -> assertEquals(200, result.getStatusCode().intValue(), "Expected 200 OK for update"),
            () -> assertEquals(productId, updatedProduct.getId()),
            () -> assertEquals(updatedDetails.getName(), updatedProduct.getName()),
            () -> assertEquals(updatedDetails.getDescription(), updatedProduct.getDescription()),
            () -> assertEquals(updatedDetails.getPrice(), updatedProduct.getPrice())
    );
  }

  @Test
  void shouldNotUpdateProductWhenNotFound() throws JsonProcessingException {
    String nonExistentId = UUID.randomUUID().toString();
    APIGatewayProxyRequestEvent event = new APIGatewayProxyRequestEvent();
    event.setHttpMethod("PUT");
    event.setPath("/api/v1/products/" + nonExistentId);
    event.setPathParameters(Map.of("id", nonExistentId));

    Product updatePayload = new Product();
    updatePayload.setId(nonExistentId);
    updatePayload.setName("Attempt to update non-existent");
    event.setBody(mapper.writeValueAsString(updatePayload));

    APIGatewayProxyResponseEvent result = classUnderTest.handleRequest(event, null);
    assertEquals(404, result.getStatusCode().intValue(), "Expected 404 Not Found for updating non-existent product");
  }


  @Test
  void shouldDeleteProduct() {
    Product productToDelete = mockDatastore.listProducts().get(0);
    String productId = productToDelete.getId();

    APIGatewayProxyRequestEvent event = new APIGatewayProxyRequestEvent();
    event.setHttpMethod("DELETE");
    event.setPath("/api/v1/products/" + productId);
    event.setPathParameters(Map.of("id", productId));

    APIGatewayProxyResponseEvent result = classUnderTest.handleRequest(event, null);

    assertEquals(204, result.getStatusCode().intValue(), "Expected 204 No Content for delete");
    // Verify it's actually deleted from the mock datastore - questionable as testing mock really
    assertThrows(ProductNotFoundException.class, () -> mockDatastore.getProductById(productId));
  }

  @Test
  void shouldNotDeleteProductWhenNotFound() {
    String nonExistentId = UUID.randomUUID().toString();
    APIGatewayProxyRequestEvent event = new APIGatewayProxyRequestEvent();
    event.setHttpMethod("DELETE");
    event.setPath("/api/v1/products/" + nonExistentId);
    event.setPathParameters(Map.of("id", nonExistentId));

    APIGatewayProxyResponseEvent result = classUnderTest.handleRequest(event, null);
    assertEquals(404, result.getStatusCode().intValue(), "Expected 404 Not Found for deleting non-existent product");
  }
}